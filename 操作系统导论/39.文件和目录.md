### 1.文件和目录

存储虚拟化形成两个抽象，一个是文件（file），每个文件都有一个与其关联的inode号。第二个抽象是目录（directory），一个目录，也像文件一样，有一个低级名字（即inode号），但它的内容特别具体：包含一个（用户可读名字，低级名字）对的列表。

假设存在一个低级别名称为“10”的文件，它的用户可读的名称为“foo”。“foo”所在的目录因此会有条目（“foo”，“10”），将用户可读名称映射到低级名称。


### 2.文件系统接口
从创建、访问和删除文件的基础开始，熟悉各个命令背后的系统调用。
你会发现，删除文件使用unlink()调用。

#### 2.1 创建文件

创建一个文件，可以从open系统调用完成。

```
int fd = open("foo",O_CREAT | O_WRONLY | O_TRUNC)
```

创建文件的旧方法是调用creat()


```
int fd = creat("foo")
```
你可以认为creat()是open()加上以下标志：O_CREAT | O_WRONLY |O_TRUNC.

open()返回值：文件描述符（file descriptor）.文件描述符是一个整数，每个进程私有，在UNIX系统中用于访问文件。

因此，一旦文件被打开，你就可以使用文件描述符来读取或写入文件。

一个文件描述符就是一种权限（capability）[L84]，即一个不透明的句柄，它可以让你执行某些操作。另一种看待文件描述符的方法，是将它作为指向文件类型对象的指针。一旦你有这样的对象，就可以调用其他“方法”来访问文件，如read()和write()。

#### 2.2 读写文件

读取现有的文件：

```
echo hello > foo
cat foo
```

cat 文件如何访问foo？通过strace工具（macOS中是dtruss），跟踪程序做的系统调用，然后将跟踪结果显示在屏幕上。

strace的参数：
- -f 跟踪所有fork的子进程。
- -t 报告每次调用的时间
- -e trace=open,close,read,write只跟踪对这些系统调用的调用，并忽略所有其他调用。


```
 root@localhost > strace cat foo
...
open("foo",O_RDONLY|O_LARGEFILE)                = 3
read(3,"hello\n",4096)                          = 6
write(1,"hello\n",6)                            = 6
hello
read(3,"",4096)                                 = 0
close(3)                                        = 0

...

```

为什么第一次调用open()会返回3，而不是0或1？事实证明，每个正在运行的进程已经打开了3个文件：标准输入（进程可以读取以接收输入），标准输出（进程可以写入以便将信息显示到屏幕），以及标准错误（进程可以写入错误消息）。这些分别由文件描述符0、1和2表示。因此，当你第一次打开另一个文件时（如上例所示），它几乎肯定是文件描述符3。

打开成功后，cat使用read()系统调用重复读取文件中的一些字节。read()的第一个参数是文件描述符，从而告诉文件系统读取哪个文件。一个进程当然可以同时打开多个文件，因此描述符使操作系统能够知道某个特定的读取引用了哪个文件。第二个参数指向一个用于放置read()结果的缓冲区。第三个参数是缓冲区的大小，在这个例子中是4KB。对read()的调用也成功返回，这里返回它读取的字节数（6，其中包括“hello”中的5个字母和一个行尾标记）。

对write()系统调用的一次调用，针对文件描述符1。如上所述，此描述符被称为标准输出，因此用于将单词“Hello”写到屏幕上，这正是cat程序要做的事。

然后，cat程序试图从文件中读取更多内容，但由于文件中没有剩余字节，read()返回0，程序知道这意味着它已经读取了整个文件。因此，程序调用close()，传入相应的文件描述符，表明它已用完文件“foo”。该文件因此被关闭，对它的读取完成了。

#### 2.3 读取和写入，但不按顺序

有时需要读取文件中的特定偏移量，通过使用lseek()系统调用。


```
off_t lseek(int fildes,off_t offset,int whence)
```
第一个参数是熟悉的（一个文件描述符）。第二个参数是偏移量，它将文件偏移量定位到文件中的特定位置。第三个参数，由于历史原因而被称为whence，明确地指定了搜索的执行方式。

打开文件的抽象包括它具有当前偏移量，偏移量的更新有两种方式。第一种是当发生N个字节的读或写时，N被添加到当前偏移。因此，每次读取或写入都会隐式更新偏移量。第二种是明确的lseek，它改变了上面指定的偏移量。

请注意，调用lseek()与移动磁盘臂的磁盘的寻道（seek）操作无关。对lseek()的调用只是改变内核中变量的值。执行I/O时，根据磁盘头的位置，磁盘可能会也可能不会执行实际的寻道来完成请求。

#### 2.4 用fsync()立即写入

当程序调用write()时，它只是告诉文件系统：请在将来的某个时刻，将此数据写入持久存储。出于性能的原因，文件系统会将这些写入在内存中缓冲（buffer）一段时间（例如5s或30s）。

在UNIX中，提供给应用程序的接口被称为fsync(int fd)。当进程针对特定文件描述符调用fsync()时，文件系统通过强制将所有脏（dirty）数据（即尚未写入的）写入磁盘来响应，针对指定文件描述符引用的文件。一旦所有这些写入完成，fsync()例程就会返回。

#### 2.5 文件重命名

有时需要给一个文件一个不同的名字。在命令行键入时，这是通过mv命令完成的。下面例子，文件foo被重命名为bar。


```
mv foo bar
```

利用strace，我们可以看到mv使用了系统调用rename(char * old, char * new)，它只需要两个参数：文件的原来名称（old）和新名称（new）。

rename()调用提供了一个有趣的保证：它（通常）是一个原子（atomic）调用，不论系统是否崩溃。

#### 2.6 获取文件信息
除了文件访问之外，我们还希望文件系统能够保存关于它正在存储的每个文件的大量信息。我们通常将这些数据称为文件元数据（metadata）。

要查看特定文件的元数据，我们可以使用stat()或fstat()系统调用。

#### 2.7 删除文件

如何删除文件？如果用过UNIX，你可能认为你知道：只需运行程序rm。但是，rm使用什么系统调用来删除文件？


```
strace rm foo
...
unlink("foo")
...
```
但这引出了一个很大的疑问：为什么这个系统调用名为“unlink”？为什么不就是“remove”或“delete”？要理解这个问题的答案，我们不仅要先了解文件，还有目录。

### 3 目录
#### 3.1 创建目录
要创建目录，可以用系统调用mkdir()。


```
strace mkdir foo
...
mkdir("foo",0777)               = 0 
...
```

一次删除一堆文件


```
rm *
```

你可以告诉rm以递归方式进入每个目录并删除其内容


```
rm -rf *
```

具体来说，空目录有两个条目：一个引用自身的条目，一个引用其父目录的条目。前者称为“.”（点）目录，后者称为“..”（点-点）目录。

#### 3.1 读取目录

不是像打开文件一样打开一个目录，而是使用一组新的调用。
使用了opendir()、readdir()和closedir()这3个调用来完成工作。

#### 3.2 删除目录
通过调用rmdir()来删除目录（它由相同名称的程序rmdir使用）。
rmdir()要求该目录在被删除之前是空的（只有“.”和“..”条目）。

### 4 链接
#### 4.1 硬链接

当你将一个新的文件名“链接”到一个旧的文件名时，你实际上创建了另一种引用同一个文件的方法。

命令行程序ln用于执行此操作。


```
> echo hello > file
> cat file
hello
>ln file file2
>cat file2
hello
```

link只是在要创建链接的目录中创建了另一个名称，并将其指向原有文件的相同inode号（即低级别名称）。该文件不以任何方式复制。

相反，你现在就有了两个人类可读的名称（file和file2），都指向同一个文件。


```
>ls -i file file2
68241902 file
68241902 file2
```

通过带-i标志的ls，它会打印出每个文件的inode编号（以及文件名）。因此，你可以看到实际上已完成的链接：只是对同一个inode号（本例中为68241902）创建了新的引用。

创建一个文件时，实际上做了两件事。首先，要构建一个结构（inode），它将跟踪几乎所有关于文件的信息，包括其大小、文件块在磁盘上的位置等等。其次，将人类可读的名称链接到该文件，并将该链接放入目录中。

在创建文件的硬链接之后，在文件系统中，原有文件名（file）和新创建的文件名（file2）之间没有区别。

因此，为了从文件系统中删除一个文件，我们调用unlink()。在上面的例子中，我们可以删除文件名file，并且仍然毫无困难地访问该文件：


```
>rm file
removed 'file'
>cat file2
hello
```

这样的结果是因为当文件系统取消链接文件时，它检查inode号中的引用计数（reference count）。该引用计数（有时称为链接计数，link count）允许文件系统跟踪有多少不同的文件名已链接到这个inode。调用unlink()时，会删除人类可读的名称（正在删除的文件）与给定inode号之间的“链接”，并减少引用计数。只有当引用计数达到零时，文件系统才会释放inode和相关数据块，从而真正“删除”该文件。

可以使用stat()来查看文件的引用计数。

#### 4.2 符号链接
还有一种非常有用的链接类型，称为符号链接（symbolic link），有时称为软链接（soft link）。

事实表明，硬链接有点局限：你不能创建目录的硬链接（因为担心会在目录树中创建一个环）。你不能硬链接到其他磁盘分区中的文件（因为inode号在特定文件系统中是唯一的，而不是跨文件系统），等等。因此，人们创建了一种称为符号链接的新型链接。


要创建这样的链接，可以使用相同的程序ln，但使用-s标志。

```
>echo hello > file
>ln -s file file2
>cat file2
hello
```

符号链接实际上与硬链接完全不同。第一个区别是符号链接本身实际上是一个不同类型的文件。我们已经讨论过常规文件和目录。符号链接是文件系统知道的第三种类型。

对符号链接运行stat揭示了一切。


```
>stat file
...regular file...
>stat file2
... symbolic link ...
```

如果仔细观察ls输出的长格式的第一个字符，可以看到常规文件最左列中的第一个字符是“-”，目录是“d”，软链接是“l”。

file2是4个字节，原因在于形成符号链接的方式，即将链接指向文件的路径名作为链接文件的数据。因为我们链接到一个名为file的文件，所以我们的链接文件file2很小（4个字节）。如果链接到更长的路径名，链接文件会更大。

最后，由于创建符号链接的方式，有可能造成所谓的悬空引用（danglingreference）。


```
>echo hello > file
>ln -s file file2
>cat file2
hello
>rm file
>cat file2
cat:file2:No such file or directory
```

符号链接与硬链接完全不同，删除名为file的原始文件会导致符号链接指向不再存在的路径名。

### 5 创建并挂载文件系统
如何从许多底层文件系统组建完整的目录树。这项任务的实现是先制作文件系统，然后挂载它们，使其内容可以访问。

为了创建一个文件系统，大多数文件系统提供了一个工具，通常名为mkfs（发音为“make fs”），它就是完成这个任务的。

思路如下：作为输入，为该工具提供一个设备（例如磁盘分区，例如/dev/sda1），一种文件系统类型（例如ext3），它就在该磁盘分区上写入一个空文件系统，从根目录开始。

但是，一旦创建了这样的文件系统，就需要在统一的文件系统树中进行访问。这个任务是通过mount程序实现的（它使底层系统调用mount()完成实际工作）。

mount的作用很简单：以现有目录作为目标挂载点（mount point），本质上是将新的文件系统粘贴到目录树的这个点上。

我们有一个未挂载的ext3文件系统，存储在设备分区/dev/sda1中，它的内容包括：一个根目录，其中包含两个子目录a和b，每个子目录依次包含一个名为foo的文件。

假设希望在挂载点/home/users上挂载此文件系统。输入以下命令：

```
>mount -t ext3 /dev/sda1 /home/users
```
如果成功，mount就让这个新的文件系统可用了。但是，请注意现在如何访问新的文件系统。要查看那个根目录的内容，我们将这样使用ls：


```
>ls /home/users/
a b
```
路径名/home/users/现在指的是新挂载目录的根。同样，我们可以使用路径名/home/users/a和/home/users/b访问文件a和b。最后，可以通过/home/users/a/foo和/home/users/ b/foo访问名为foo的两个文件。

因此mount的美妙之处在于：它将所有文件系统统一到一棵树中，而不是拥有多个独立的文件系统，这让命名统一而且方便。
